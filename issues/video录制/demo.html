<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    video {
      width: 400px;
      height: 300px;
    }
  </style>
</head>

<body>
  <video src="./video.mp4" id="leftVideo" controls="controls"></video>
  <video id="rightVideo" controls="controls"></video>
  <button id="btn" click="btn">ä¸‹è½½</button>
  <script src="https://www.webrtc-experiment.com/EBML.js"></script>
  <script>
    // sketch.js

    const bodyEl = document.getElementsByTagName("body")[0]

    const recordBtn = document.createElement('button')

    recordBtn.innerHTML = 'âºï¸ Start record'

    bodyEl.append(recordBtn)


    const videoChunks = [];

    let videoRecorder;

    let isRecording = false;

    let recordingTime = 0

    let recordBtnTimer

    let captureFrameRate = 50


    const startRecord = () => {

      videoChunks.length = 0;

      // 1.è¯»å–canvasè§†é¢‘æµ

      let stream = document.querySelector('#leftVideo').captureStream(captureFrameRate);

      // 2.åˆ›å»ºè§†é¢‘å½•åˆ¶å™¨

      const options = { mimeType: 'video/webm;codecs=vp8' };

      videoRecorder = new MediaRecorder(stream, options);

      videoRecorder.ondataavailable = e => {

        if (e.data.size) {

          videoChunks.push(e.data);

        }

      };

      videoRecorder.onstop = exportVideo;

      // 3.å¼€å§‹å½•åˆ¶

      videoRecorder.start();


      // 4.æ”¹å˜æŒ‰é’®çŠ¶æ€

      recordBtn.onclick = stopRecord

      isRecording = true;

      recordBtn.textContent = 'ğŸ”´ Recording 0s';

      recordBtnTimer = setInterval(() => { // Update recording text every second

        recordingTime += 1

        recordBtn.textContent = `ğŸ”´ Recording ${recordingTime}s`

      }, 1000)

    }


    const stopRecord = () => {

      videoRecorder.stop();

      isRecording = false;

      recordBtn.textContent = 'âºï¸ Start record';

      clearInterval(recordBtnTimer) // clear timer

      recordingTime = 0

      recordBtn.onclick = startRecord;

    }


    const exportVideo = () => {

      let blob = new Blob(videoChunks, { "type": "video/webm;codecs=vp8;" });

      const { Decoder, tools, Reader } = EBML

      const reader = new Reader()

      const decoder = new Decoder()


      const fileReader = new FileReader()

      fileReader.onload = function () {

        // 1.è§£æè§†é¢‘blob
        console.log(this.result);
        const ebmlList = decoder.decode(this.result)

        ebmlList.forEach(item => reader.read(item))

        reader.stop()

        // 2.è·å–å…ƒæ•°æ®

        const refinedMetadataBuf = tools.makeMetadataSeekable(

          reader.metadatas,

          reader.duration,

          reader.cues

        )

        // 3.è·å–å…ƒæ•°æ®å¤§å°

        const body = this.result.slice(reader.metadataSize)

        // 4.å†™å…¥å…ƒæ•°æ®

        const newBlob = new Blob([refinedMetadataBuf, body], {

          type: 'video/mp4;'

        })

        // 5.å°†blobè½¬æˆurl
        const refinedUrl = URL.createObjectURL(newBlob)

        // 6.è‡ªåŠ¨ä¸‹è½½
        let a = document.createElement('a')
        a.href = refinedUrl;
        a.style = "display: none";
        a.download = `${new Date().toISOString().replace(/T/, ' ').replace(/\..+/, '')}.mp4`;
        a.click();
      }
      fileReader.readAsArrayBuffer(blob)
    }
    recordBtn.onclick = startRecord;


  </script>
  <!-- <script>
    var leftVideo = document.getElementById('leftVideo');
    var rightVideo = document.getElementById('rightVideo');
    var btn = document.getElementById('btn');

    let buffer = [], stream;
    leftVideo.onplay = function () {
      stream = leftVideo.captureStream();
      streamLists()
    };
    function streamLists() {
      let mediaRecorder = new MediaRecorder(stream);
      mediaRecorder.ondataavailable = (e) => {
        buffer.push(e.data);
      }
      mediaRecorder.start(10);
    }
    btn.addEventListener("click", function () {
      var blob = new Blob(buffer, { type: 'video/webm' });
      var url = window.URL.createObjectURL(blob);
      rightVideo.src = url
      var a = document.createElement('a'); a.download = ''; a.href = url; a.click()
    })

  </script>
  <script>
    // å®šä¹‰ä¸€ä¸ªæ·±æ‹·è´å‡½æ•°  æ¥æ”¶ç›®æ ‡targetå‚æ•°
    function deepClone(target) {
      // å®šä¹‰ä¸€ä¸ªå˜é‡
      let result;
      // å¦‚æœå½“å‰éœ€è¦æ·±æ‹·è´çš„æ˜¯ä¸€ä¸ªå¯¹è±¡çš„è¯
      if (typeof target === 'object') {
        // å¦‚æœæ˜¯ä¸€ä¸ªæ•°ç»„çš„è¯
        if (Array.isArray(target)) {
          result = []; // å°†resultèµ‹å€¼ä¸ºä¸€ä¸ªæ•°ç»„ï¼Œå¹¶ä¸”æ‰§è¡Œéå†
          for (let i in target) {
            // é€’å½’å…‹éš†æ•°ç»„ä¸­çš„æ¯ä¸€é¡¹
            result.push(deepClone(target[i]))
          }
          // åˆ¤æ–­å¦‚æœå½“å‰çš„å€¼æ˜¯nullçš„è¯ï¼›ç›´æ¥èµ‹å€¼ä¸ºnull
        } else if (target === null) {
          result = null;
          // åˆ¤æ–­å¦‚æœå½“å‰çš„å€¼æ˜¯ä¸€ä¸ªRegExpå¯¹è±¡çš„è¯ï¼Œç›´æ¥èµ‹å€¼    
        } else if (target.constructor === RegExp) {
          result = target;
        } else {
          // å¦åˆ™æ˜¯æ™®é€šå¯¹è±¡ï¼Œç›´æ¥for inå¾ªç¯ï¼Œé€’å½’èµ‹å€¼å¯¹è±¡çš„æ‰€æœ‰å€¼
          result = {};
          for (let i in target) {
            result[i] = deepClone(target[i]);
          }
        }
        // å¦‚æœä¸æ˜¯å¯¹è±¡çš„è¯ï¼Œå°±æ˜¯åŸºæœ¬æ•°æ®ç±»å‹ï¼Œé‚£ä¹ˆç›´æ¥èµ‹å€¼
      } else {
        result = target;
      }
      // è¿”å›æœ€ç»ˆç»“æœ
      return result;
    }
  </script> -->
</body>

</html>